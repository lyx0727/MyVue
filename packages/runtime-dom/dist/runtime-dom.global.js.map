{
  "version": 3,
  "sources": ["../src/index.ts", "../../shared/src/index.ts", "../../reactivity/src/effect.ts", "../../reactivity/src/reactive.ts", "../../runtime-core/src/componentProps.ts", "../../runtime-core/src/component.ts", "../../runtime-core/src/scheduler.ts", "../../runtime-core/src/vnode.ts", "../../runtime-core/src/renderer.ts", "../../runtime-core/src/h.ts", "../src/nodeOps.ts", "../src/modules/attr.ts", "../src/modules/class.ts", "../src/modules/event.ts", "../src/modules/style.ts", "../src/patchProp.ts"],
  "sourcesContent": ["import { createRenderer } from \"@vue/runtime-core\";\r\nimport { nodeOps } from \"./nodeOps\";\r\nimport { patchProp } from \"./patchProp\";\r\n\r\nconst renderOptions =  Object.assign(nodeOps, {patchProp});\r\n\r\nexport function render(vnode:any, container:any){\r\n    return createRenderer(renderOptions).render(vnode, container);\r\n}\r\n\r\nexport * from '@vue/runtime-core';", "export const isObject = (value:any)=>{\r\n    return value !== null && typeof value === \"object\";\r\n}\r\n\r\nexport const isFunction = (value:any)=>{\r\n    return typeof value === 'function';\r\n}\r\n\r\nexport const isString = (value:any)=>{\r\n    return typeof value === 'string';\r\n}\r\n\r\nexport const isArray = Array.isArray;\r\nexport const assign = Object.assign;\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nexport const hasOwn = (value:any, key:string|symbol)=>hasOwnProperty.call(value, key);\r\n\r\nexport const enum ShapeFlags {\r\n    ELEMENT                     = 1,\r\n    FUNCTIONAL_COMPONENT        = 1 << 1,\r\n    STATEFUL_COMPONENT          = 1 << 2,\r\n    TEXT_CHILDREN               = 1 << 3,\r\n    ARRAY_CHILDREN              = 1 << 4,\r\n    SLOTS_CHILDREN              = 1 << 5,\r\n    TELEPORT                    = 1 << 6,\r\n    SUSPENSE                    = 1 << 7,\r\n    COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,\r\n    COMPONENT_KEPT_ALIVE        = 1 << 9,\r\n    COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT\r\n};", "// current 'effect'\r\nexport let activeEffect:any = undefined;\r\n\r\nfunction cleanupEffects(effect:any){\r\n    const {deps} = effect;\r\n    for(let i = 0; i < deps.length; i++){\r\n        deps[i].delete(effect);\r\n    }\r\n    effect.deps.length = 0;\r\n}\r\n\r\nexport class ReactiveEffect{\r\n    public active = true;\r\n    public parent = null;\r\n    public deps = [];\r\n\r\n    constructor(public fn:Function, public scheduler?:Function) {}\r\n    \r\n    run(){\r\n        if(!this.active){\r\n            return this.fn();\r\n        }\r\n        try{\r\n            // in case be invoked by another 'effect'\r\n            // stack push\r\n            this.parent = activeEffect;\r\n            // set current 'effect'\r\n            activeEffect = this;\r\n            // clean dependencys to collect again\r\n            // in case condition branch\r\n            cleanupEffects(this);\r\n\r\n            return this.fn();\r\n        }\r\n        finally{\r\n            // stack pop\r\n            activeEffect = this.parent;\r\n        }\r\n    }\r\n\r\n    stop(){\r\n        if(this.active){\r\n            this.active = false;\r\n            cleanupEffects(this);\r\n        }\r\n    }\r\n}\r\n\r\nexport function effect(fn:Function, options:any = {}){\r\n    const _effect = new ReactiveEffect(fn, options.scheduler);\r\n    _effect.run();\r\n\r\n    // bind this\r\n    const runner:any = _effect.run.bind(_effect);\r\n    // mount 'effect' on 'runner'\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\n\r\nexport function trackEffects(dep:any){\r\n    if(activeEffect){\r\n        let shouldTrack = !dep.has(activeEffect);\r\n        if(shouldTrack){\r\n            // bidirectional map\r\n            dep.add(activeEffect);\r\n            activeEffect.deps.push(dep);\r\n        }\r\n    }\r\n}\r\n\r\nconst targetMap = new WeakMap();\r\nexport function track(target:any, type:string, key:string|symbol){\r\n    if(!activeEffect) return;\r\n    let depsMap = targetMap.get(target);\r\n    if(!depsMap){\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if(!dep){\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    trackEffects(dep);\r\n}\r\n\r\nexport function triggerEffects(effects:any){\r\n    if(effects){\r\n        // copy to avoid infinite loop\r\n        effects = new Set(effects);\r\n        effects.forEach((effect:any) => {\r\n            // avoid self-recursion\r\n            if(effect !== activeEffect){\r\n                if(effect.scheduler){\r\n                    effect.scheduler();\r\n                }\r\n                else{\r\n                    effect.run();\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nexport function trigger(target:any, type:string, key:string|symbol, value:any, oldValue:any){\r\n    const depsMap = targetMap.get(target);\r\n    if(!depsMap) return;\r\n\r\n    let effects = depsMap.get(key);\r\n\r\n    triggerEffects(effects);\r\n}", "import { isObject } from \"@vue/shared\";\r\nimport { track } from \"./effect\";\r\nimport { trigger } from \"./effect\";\r\n\r\n// record object which has had proxy\r\nconst reactiveMap = new WeakMap();\r\n\r\nconst enum ReactiveFlags {\r\n    IS_REACTIVE = '__v_isReactive'\r\n};\r\n\r\nexport function isReactive(target:any){\r\n    return target && target[ReactiveFlags.IS_REACTIVE];\r\n}\r\n\r\nexport function reactive(target: any){\r\n    // only for Object-type\r\n    if(!isObject(target)){  \r\n        return target;\r\n    }\r\n\r\n    // can have exactly ONE proxy\r\n    const exisitingProxy = reactiveMap.get(target);\r\n    if(exisitingProxy){\r\n        return exisitingProxy;\r\n    }\r\n\r\n    // 'target' has been a proxy\r\n    if(isReactive(target)){\r\n        return target;\r\n    }\r\n\r\n    const proxy:any = new Proxy(target, {\r\n        get(target, key, receiver){\r\n            if(key === ReactiveFlags.IS_REACTIVE){\r\n                return true;\r\n            }\r\n\r\n            track(target, 'get', key);\r\n\r\n            // receiver: proxy\r\n            // change 'this' from 'target' to 'proxy'\r\n            // in case 'get' a attribute which invoke 'get' again\r\n            const res = Reflect.get(target, key, receiver);\r\n            if(isObject(res)){\r\n                return reactive(res); \r\n            }\r\n            return res;\r\n        },\r\n        set(target, key, value, receiver){\r\n            let oldValue = target[key];\r\n            let result = Reflect.set(target, key, value, receiver);\r\n            \r\n            // changed\r\n            if(oldValue !== value){\r\n                trigger(target, 'set', key, value, oldValue);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    })\r\n    // record\r\n    reactiveMap.set(target, proxy);\r\n    return proxy;\r\n}", "import { reactive } from \"@vue/reactivity\";\r\nimport { hasOwn } from \"@vue/shared\";\r\n\r\nexport function initProps(instance:any, rawProps:any){\r\n    const props:any = {};\r\n    const attrs:any = {};\r\n\r\n    const options = instance.propsOptions || {};\r\n    if(rawProps){\r\n        for(let key in rawProps){\r\n            const value = rawProps[key];\r\n            if(hasOwn(options, key)){\r\n                props[key] = value;\r\n            }\r\n            else{\r\n                attrs[key] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    // shallowReactive\r\n    instance.props = reactive(props);\r\n    instance.attrs = attrs;\r\n}\r\n\r\nexport const hasPropsChanged = (prevProps:any = {}, nextProps:any = {})=>{\r\n    const nextKeys = Object.keys(nextProps);\r\n    if(nextKeys.length !== Object.keys(prevProps).length){\r\n        return true;\r\n    }\r\n    for(let i = 0; i < nextKeys.length; i++){\r\n        const key = nextKeys[i];\r\n        if(nextProps[key] !== prevProps[key]){\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function updateProps(prevProps:any, nextProps:any){\r\n    if(hasPropsChanged(prevProps, nextProps)){\r\n        for(const key in nextProps){\r\n            prevProps[key] = nextProps[key];\r\n        }\r\n        for(const key in prevProps){\r\n            if(!hasOwn(nextProps, key)){\r\n                delete prevProps[key];\r\n            }\r\n        }\r\n    }\r\n}", "import { reactive } from \"@vue/reactivity\";\r\nimport { hasOwn, isFunction } from \"@vue/shared\";\r\nimport { initProps } from \"./componentProps\";\r\n\r\nexport function createComponentInstance(vnode:any){\r\n    const instance = {\r\n        data: null, \r\n        vnode,  // '_vnode' in vue2\r\n        subTree: null,  \r\n        isMounted: false,\r\n        update: ()=>{},\r\n        propsOptions: vnode.type.props,\r\n        props: {},\r\n        attrs: {},\r\n        proxy: null,\r\n        render: null\r\n    };\r\n    return instance;\r\n}\r\n\r\nconst publicPropertyMap:any = {\r\n    $attrs: (i:any)=>i.attrs\r\n}\r\n\r\nconst publicInstanceProxy = {\r\n    get(target:any, key:string|symbol){\r\n        const {data, props} = target;\r\n        if(data && hasOwn(data, key)){\r\n            return data[key];\r\n        }\r\n        else if(props && hasOwn(props, key)){\r\n            return props[key];\r\n        }\r\n        // this.$attrs\r\n        let getter = publicPropertyMap[key];\r\n        if(getter){\r\n            return getter(target);\r\n        }\r\n    },\r\n    set(target:any, key:string|symbol, value:any){\r\n        const {data, props} = target;\r\n        if(data && hasOwn(data, key)){\r\n            data[key] = value;\r\n            return true;\r\n        }\r\n        else if(props && hasOwn(props, key)){\r\n            console.warn('attemping to mutate prop ' + (key as string));\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nexport function setupComponent(instance:any){\r\n    let {props, type} = instance.vnode;\r\n\r\n    initProps(instance, props);\r\n    instance.proxy = new Proxy(instance, publicInstanceProxy);\r\n\r\n    let data = type.data;\r\n    if(data){\r\n        if(!isFunction(data)){\r\n            return console.warn('data option must be a function');\r\n        }\r\n        instance.data = reactive(data.call(instance.proxy));\r\n    }\r\n    instance.render = type.render;\r\n}", "const queue:any = [];\r\nlet isFlushing = false;\r\nconst resolvePromise = Promise.resolve();\r\n\r\nexport function queueJob(job:any){\r\n    if(!queue.includes(job)){\r\n        queue.push(job);\r\n    }\r\n    if(!isFlushing){\r\n        isFlushing = true;\r\n        resolvePromise.then(()=>{\r\n            isFlushing = false;\r\n            let copy = queue.slice();\r\n            queue.length = 0;\r\n            for(let i = 0; i < copy.length; i++){\r\n                let job = copy[i];\r\n                job();\r\n            }\r\n            copy.length = 0;\r\n        });    \r\n    }\r\n}\r\n", "import { isArray, isFunction, isObject, isString, ShapeFlags } from \"@vue/shared\";\r\n\r\nexport const Text = Symbol(\"Text\");\r\nexport const Fragment = Symbol(\"Fragment\");\r\n\r\nexport function isVnode(value:any){\r\n    return value && value.__v_isVnode;\r\n}\r\n\r\nexport function isSameVnode(n1:any, n2:any){\r\n    return (n1.type === n2.type) && (n1.key === n2.key);\r\n}\r\n\r\nexport function createVnode(type:any, props:any, children:any = null){\r\n    let shapeFlag = \r\n        isString(type) ? ShapeFlags.ELEMENT : \r\n        isObject(type) ? ShapeFlags.STATEFUL_COMPONENT :\r\n        isFunction(type) ? ShapeFlags.FUNCTIONAL_COMPONENT : 0;\r\n    \r\n    const vnode = {\r\n        type,\r\n        props,\r\n        children,\r\n        el: null,\r\n        key: props?.['key'],\r\n        __v_isVnode: true,\r\n        shapeFlag\r\n    };\r\n\r\n    if(children){\r\n        let type = 0;\r\n        if(isArray(children)){\r\n            type = ShapeFlags.ARRAY_CHILDREN;\r\n        }\r\n        else{\r\n            children = String(children);\r\n            type = ShapeFlags.TEXT_CHILDREN;\r\n        }\r\n        vnode.shapeFlag |= type;\r\n    }\r\n    return vnode;\r\n}", "import { reactive, ReactiveEffect } from \"@vue/reactivity\";\r\nimport { isString, ShapeFlags } from \"@vue/shared\";\r\nimport { createComponentInstance, setupComponent } from \"./component\";\r\nimport { hasPropsChanged, updateProps } from \"./componentProps\";\r\nimport { queueJob } from \"./scheduler\";\r\nimport { createVnode, isSameVnode, Text, Fragment } from \"./vnode\";\r\n\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr: number[]): number[] {\r\n    const p = arr.slice();\r\n    const result = [0];\r\n    let i, j, u, v, c;\r\n    const len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n      const arrI = arr[i];\r\n      if (arrI !== 0) {\r\n        j = result[result.length - 1];\r\n        if (arr[j] < arrI) {\r\n          p[i] = j;\r\n          result.push(i);\r\n          continue;\r\n        }\r\n        u = 0;\r\n        v = result.length - 1;\r\n        while (u < v) {\r\n          c = (u + v) >> 1;\r\n          if (arr[result[c]] < arrI) {\r\n            u = c + 1;\r\n          } else {\r\n            v = c;\r\n          }\r\n        }\r\n        if (arrI < arr[result[u]]) {\r\n          if (u > 0) {\r\n            p[i] = result[u - 1];\r\n          }\r\n          result[u] = i;\r\n        }\r\n      }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n      result[u] = v;\r\n      v = p[v];\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function createRenderer(renderOptions:any){\r\n    const {\r\n        insert: hostInsert,\r\n        remove: hostRemove,\r\n        setElementText: hostSetElementText,\r\n        setText: hostSetText,\r\n        patchProp: hostPatchProp,\r\n        createElement: hostCreateElement,\r\n        createText: hostCreateText,\r\n    } = renderOptions;\r\n\r\n    const normalize = (children:any, i:any)=>{\r\n        if(isString(children[i])){\r\n            const vnode = createVnode(Text, null, children[i]);\r\n            children[i] = vnode;\r\n        }\r\n        return children[i];\r\n    }\r\n\r\n    const unmount = (vnode:any)=>{\r\n        hostRemove(vnode.el);\r\n    };\r\n\r\n    const mountChildren = (children:any, container:any)=>{\r\n        for(let i = 0; i < children.length; i++){\r\n            let child = normalize(children, i);\r\n            patch(null, child, container);\r\n        }\r\n    }\r\n\r\n    const mountElement = (vnode:any, container:any, anchor:any = null)=>{\r\n        let {type, props, children, shapeFlag} = vnode;\r\n        let el = vnode.el = hostCreateElement(type);\r\n        if(props){\r\n            for(let key in props){\r\n                hostPatchProp(el, key, null, props[key]);\r\n            }\r\n        }\r\n        if(shapeFlag & ShapeFlags.TEXT_CHILDREN){\r\n            hostSetElementText(el, children);\r\n        }\r\n        else if(shapeFlag & ShapeFlags.ARRAY_CHILDREN){\r\n            mountChildren(children, el);\r\n        }\r\n        hostInsert(el, container, anchor);\r\n    }\r\n\r\n    const mountComponent = (vnode:any, container:any, anchor:any = null)=>{\r\n        // 1. create an instance\r\n        const instance = vnode.component = createComponentInstance(vnode);\r\n\r\n        // 2. assign value to the instance\r\n        setupComponent(instance);\r\n\r\n        // 3. create an 'effect'\r\n        setupRenderEffect(instance, container, anchor);\r\n    }\r\n\r\n    const updateComponentPreRender = (instance:any, next:any)=>{\r\n        instance.next = null;\r\n        instance.vnode = next;\r\n        updateProps(instance.props, next.props);\r\n    }\r\n\r\n    const setupRenderEffect = (instance:any, container:any, anchor:any)=>{\r\n        const componentUpdateFn = ()=>{\r\n            const {render} = instance;\r\n            // mount\r\n            if(!instance.isMounted){\r\n                // set 'state' as 'this'\r\n                const subTree = render.call(instance.proxy);\r\n                patch(null, subTree, container, anchor);\r\n                instance.subTree = subTree;\r\n                instance.isMounted = true;\r\n            }\r\n            // update\r\n            else{\r\n                let {next} = instance;\r\n                if(next){\r\n                    updateComponentPreRender(instance, next);\r\n                }\r\n\r\n                const subTree = render.call(instance.proxy);\r\n                patch(instance.subTree, subTree, container, anchor);\r\n                instance.subTree = subTree;\r\n            }\r\n        }\r\n\r\n        const effect = new ReactiveEffect(\r\n            componentUpdateFn, \r\n            // scheduler, avoid 'render' invokes some 'render' \r\n            ()=>{queueJob(instance.update)}\r\n        );\r\n        const update = instance.update = effect.run.bind(effect);\r\n        update();\r\n    }\r\n\r\n    const processText = (n1:any, n2:any, container:any)=>{\r\n        if(n1 == null){\r\n            hostInsert((n2.el = hostCreateText(n2.children)), container);\r\n        }\r\n        else{\r\n            // 'text' changed, reuse old node\r\n            const el = n2.el = n1.el;\r\n            if(n1.children !== n2.children){\r\n                hostSetText(el, n2.children);\r\n            }\r\n        }\r\n    }\r\n\r\n    const processFragment = (n1:any, n2:any, container:any)=>{\r\n        if(n1 == null){\r\n            mountChildren(n2.children, container);\r\n        }\r\n        else{\r\n            patchChildren(n1, n2, container);\r\n        }\r\n    }\r\n\r\n    const processElement = (n1:any, n2:any, container:any, anchor:any = null)=>{\r\n        // mount\r\n        if(n1 == null){\r\n            mountElement(n2, container, anchor);\r\n        }\r\n        // update\r\n        else{\r\n            patchElement(n1, n2, container,);\r\n        }\r\n    }\r\n\r\n    const shouldUpdateComponent = (n1:any, n2:any)=>{\r\n        const {props:prevProps, children:prevChildren} = n1;\r\n        const {props:nextProps, children:nextChildren} = n2;\r\n\r\n        if(prevProps === nextProps){\r\n            return false;\r\n        }\r\n        if(prevChildren || nextChildren){\r\n            return true;\r\n        }\r\n        return hasPropsChanged(n1, n2);\r\n    }\r\n\r\n    const updateComponent = (n1:any, n2:any)=>{\r\n        // for component, reuse 'instance'\r\n        const instance = (n2.component = n1.component);\r\n        \r\n\r\n        if(shouldUpdateComponent(n1, n2)){\r\n            instance.next = n2;\r\n            instance.update();\r\n        }\r\n        \r\n    }\r\n    \r\n    const processComponent = (n1:any, n2:any, container:any, anchor:any = null)=>{\r\n        // mount\r\n        if(n1 == null){\r\n            mountComponent(n2, container, anchor);\r\n        }\r\n        // update\r\n        else{\r\n            updateComponent(n1, n2);\r\n        }\r\n    }\r\n\r\n    const patchProps = (oldProps:any, newProps:any, el:any)=>{\r\n        for(let key in newProps){\r\n            hostPatchProp(el, key, oldProps[key], newProps[key]);\r\n        }\r\n\r\n        for(let key in oldProps){\r\n            if(newProps[key] == null){\r\n                hostPatchProp(el, key, oldProps[key], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    const unmountChildren = (children:any)=>{\r\n        for(let i = 0; i < children.length; i++){\r\n            unmount(children[i]);\r\n        }\r\n    }\r\n\r\n    const patchChildren = (n1:any, n2:any, el:any)=>{\r\n        const c1 = n1.children;\r\n        const c2 = n2.children;\r\n        const prevShapeFlag = n1.shapeFlag;\r\n        const shapeFlag = n2.shapeFlag;\r\n        // { (old -> new) | old, new in { null, text, array } }\r\n\r\n        //  (null | text | array -> text)\r\n        if(shapeFlag & ShapeFlags.TEXT_CHILDREN){\r\n            // (array -> text)\r\n            if(prevShapeFlag & ShapeFlags.ARRAY_CHILDREN){\r\n                // clear previous array\r\n                unmountChildren(c1);\r\n            }\r\n            // (null | text -> text)\r\n            if(c1 !== c2){\r\n                hostSetElementText(el, c2);\r\n            }\r\n        }\r\n        // (null | text | array -> null | array)\r\n        else{\r\n            // (array -> null | array)\r\n            if(prevShapeFlag & ShapeFlags.ARRAY_CHILDREN){\r\n                 // (array -> array)\r\n                if(shapeFlag & ShapeFlags.ARRAY_CHILDREN){\r\n                    // diff\r\n                    let i = 0;\r\n                    let e1 = c1.length - 1;\r\n                    let e2 = c2.length - 1;\r\n\r\n                    while(i <= e1 && i <= e2){\r\n                        const n1 = c1[i];\r\n                        const n2 = c2[i];\r\n                        if(isSameVnode(n1, n2)){\r\n                            patch(n1, n2, el);\r\n                        }\r\n                        else{\r\n                            break;\r\n                        }\r\n                        i++;\r\n                    }\r\n\r\n                    while(i <= e1 && i <= e2){\r\n                        const n1 = c1[e1];\r\n                        const n2 = c2[e2];\r\n                        if(isSameVnode(n1, n2)){\r\n                            patch(n1, n2, el);\r\n                        }\r\n                        else{\r\n                            break;\r\n                        }\r\n                        e1--;\r\n                        e2--;\r\n                    }\r\n                    // mount new node\r\n                    if(i > e1){\r\n                        if(i <= e2){\r\n                            while(i <= e2){\r\n                                const nextPos = e2 + 1;\r\n                                const anchor = nextPos < c2.length ? c2[nextPos].el : null;\r\n                                patch(null, c2[i], el, anchor);\r\n                                i++;\r\n                            }\r\n                        }\r\n                    }\r\n                    // unmount old node\r\n                    else if(i > e2){\r\n                        if(i <= e1){\r\n                            while(i <= e1){\r\n                                unmount(c1[i]);\r\n                                i++;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    const s1 = i;\r\n                    const s2 = i;\r\n                    const keyToNewIndexMap = new Map;\r\n                    for(let i = s2; i <= e2; i++){\r\n                        keyToNewIndexMap.set(c2[i].key, i);\r\n                    }\r\n\r\n                    const toBePatched = e2 - s2 + 1;\r\n                    let newIndexToOldIndexMap = new Array(toBePatched).fill(0);\r\n                    for(let i = s1; i <= e1; i++){\r\n                        const oldChild = c1[i];\r\n                        let newIndex = keyToNewIndexMap.get(oldChild.key);\r\n                        if(newIndex == null){\r\n                            unmount(oldChild);\r\n                        }\r\n                        else{\r\n                            newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                            patch(oldChild, c2[newIndex], el);\r\n                        }\r\n                    }\r\n                    // move to correct position\r\n                    const increasingNewIndexSequence = getSequence(newIndexToOldIndexMap);\r\n                    let j = increasingNewIndexSequence.length - 1;\r\n                    for(let i = toBePatched - 1; i >= 0; i--){\r\n                        let index = i + s2;\r\n                        let current = c2[index];\r\n                        let anchor = index + 1 < c2.length ? c2[index + 1].el : null;\r\n\r\n                        if(newIndexToOldIndexMap[i] === 0){\r\n                            patch(null, current, el, anchor);   \r\n                        }\r\n                        // patched\r\n                        else{\r\n                            if(j < 0 || i !== increasingNewIndexSequence[j]){\r\n                                hostInsert(current.el, el, anchor);\r\n                            }\r\n                            else{\r\n                                j--;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n                // (array -> null)\r\n                else{\r\n                    unmountChildren(c1);\r\n                }\r\n            }\r\n            // (null | text -> null | array)\r\n            else{\r\n                // (text -> null | array)\r\n                if(prevShapeFlag & ShapeFlags.TEXT_CHILDREN){\r\n                    // clear previous text\r\n                    hostSetElementText(el, '');\r\n                }\r\n                // (text -> array)\r\n                if(shapeFlag & ShapeFlags.ARRAY_CHILDREN){\r\n                    mountChildren(c2, el);\r\n                }\r\n                // (text -> null)\r\n                // do nothing\r\n            }\r\n        }\r\n    }\r\n\r\n    const patchElement = (n1:any, n2:any, container:any)=>{\r\n        // reuse element\r\n        const el = n2.el = n1.el;\r\n\r\n        // patch props\r\n        let oldProps = n1.props || {};\r\n        let newProps = n2.props || {};\r\n        patchProps(oldProps, newProps, el);\r\n    \r\n        // patch children\r\n        patchChildren(n1, n2, el);\r\n    }\r\n\r\n    const patch = (n1:any, n2:any, container:any, anchor:any = null)=>{\r\n        if(n1 === n2){\r\n            return;\r\n        }\r\n\r\n        // not same type, unmount old node\r\n        if(n1 && !isSameVnode(n1, n2)){\r\n            unmount(n1);\r\n            n1 = null;\r\n        }\r\n\r\n        const {type, shapeFlag} = n2;\r\n        switch(type){\r\n            case Text:\r\n                processText(n1, n2, container);\r\n                break;\r\n            case Fragment:\r\n                processFragment(n1, n2, container);\r\n                break;\r\n            default:\r\n                if(shapeFlag & ShapeFlags.ELEMENT){\r\n                    processElement(n1, n2, container, anchor);\r\n                }\r\n                else if(shapeFlag & ShapeFlags.COMPONENT){\r\n                    processComponent(n1, n2, container, anchor)\r\n                }\r\n        }            \r\n    }\r\n\r\n    const render = (vnode:any, container:any)=>{\r\n        // unmount\r\n        if(vnode === null){\r\n            if(container._vnode){\r\n                unmount(container._vnode);\r\n            }\r\n        }\r\n        // mount or update\r\n        else{\r\n            patch(container._vnode || null, vnode, container);\r\n        }\r\n\r\n        container._vnode = vnode;\r\n    };\r\n\r\n    return {\r\n        render\r\n    };\r\n}", "import { isArray, isObject } from \"@vue/shared\";\r\nimport { createVnode, isVnode } from \"./vnode\";\r\n\r\nexport function h(type:any, propsOrChildren:any, children:any){\r\n    const l = arguments.length;\r\n    if(l === 2){\r\n        if(isObject(propsOrChildren) && !isArray(propsOrChildren)){\r\n            // single 'vnode' without children\r\n            if(isVnode(propsOrChildren)){ \r\n                // wrap 'vnode' to array\r\n                return createVnode(type, null, [propsOrChildren]);\r\n            }\r\n            // props without children\r\n            return createVnode(type, propsOrChildren);\r\n        }\r\n        else{\r\n            // array, omit props\r\n            return createVnode(type, null, propsOrChildren);\r\n        }\r\n    }\r\n    else{\r\n        if(l > 3){\r\n            children = Array.prototype.slice.call(arguments, 2)\r\n        }\r\n        else if(l === 3 && isVnode(children)){\r\n            children = [children];\r\n        }\r\n        return createVnode(type, propsOrChildren, children);\r\n    }\r\n}", "export const nodeOps = {\r\n    // CURD\r\n    insert(child:any, parent:any, anchor:any = null){\r\n        parent.insertBefore(child, anchor);\r\n    },\r\n    remove(child:any){\r\n        const parentNode = child.parentNode;\r\n        if(parentNode){\r\n            parentNode.removeChild(child);\r\n        }\r\n    },\r\n    setElementText(el:any, text:string){\r\n        // it's too dangerous to use 'innerHtml' \r\n        el.textContent = text;\r\n    },\r\n    setText(node:any, text:string){\r\n        node.nodeValue = text;\r\n    },\r\n    querySelector(selector:any){\r\n        return document.querySelector(selector);\r\n    },\r\n    parentNode(node:any){\r\n        return node.parentNode;\r\n    },\r\n    nextSibling(node:any){\r\n        return node.nextSibling;\r\n    },\r\n    createElement(tagName:string){\r\n        return document.createElement(tagName);\r\n    },\r\n    createText(text:string){\r\n        return document.createTextNode(text);\r\n    },\r\n    setScopeId(el:any, id:string) {\r\n        el.setAttribute(id, '')\r\n    },\r\n    cloneNode(el:any){\r\n        return el.cloneNode(true);\r\n    }\r\n}\r\n", "export function patchAttr(el:any, key:any, nextValue:any){\r\n    if(nextValue){\r\n        el.setAttribute(key, nextValue);\r\n    }\r\n    else{\r\n        el.removeAttribute(key);\r\n    }\r\n}", "export function patchClass(el:any, nextValue:any){\r\n    if(nextValue === null){\r\n        el.removeAttribute('class');\r\n    }  \r\n    else{\r\n        el.className = nextValue;\r\n    }\r\n}", "function createInvoker(cb:any){\r\n    const invoker = (e:any) => invoker.value(e);\r\n    invoker.value = cb;\r\n    return invoker;  \r\n}\r\n\r\nexport function patchEvent(el:any, eventName:any, nextValue:any){\r\n    // 'vei' = 'vue event invoker'\r\n    // a cache for event invokers\r\n    let invokers = el._vei || (el._vei = {});\r\n    let exist = invokers[eventName];\r\n\r\n    if(exist && nextValue){\r\n        exist.value = nextValue;\r\n    }\r\n    else{\r\n        // 'onXxx' --> 'xxx'\r\n        let event = eventName.slice(2).toLowerCase();\r\n\r\n        if(nextValue){\r\n            const invoker = invokers[eventName] = createInvoker(nextValue);\r\n            el.addEventListener(event, invoker);\r\n        }\r\n        else if(exist){\r\n            el.removeEventListener(event, exist);\r\n            invokers[eventName] = undefined;\r\n        }\r\n    }\r\n}", "export function patchStyle(el:any, prevValue:any, nextValue:any){\r\n    // cover existed\r\n    for(let key in nextValue){\r\n        el.style[key] = nextValue[key];\r\n    }\r\n    // remove not want but existed\r\n    if(prevValue){\r\n        for(let key in prevValue){\r\n            if(nextValue == null || nextValue[key] == null){\r\n                el.style[key] = null;\r\n            }\r\n        }\r\n    }\r\n}", "import { patchAttr } from \"./modules/attr\";\r\nimport { patchClass } from \"./modules/class\";\r\nimport { patchEvent } from \"./modules/event\";\r\nimport { patchStyle } from \"./modules/style\";\r\n\r\nexport function patchProp(el:any, key:string, prevValue:any, nextValue:any){\r\n    if(key === 'class'){\r\n        patchClass(el, nextValue);\r\n    }\r\n    else if(key === 'style'){\r\n        patchStyle(el, prevValue, nextValue);\r\n    }\r\n    else if(/^on[^a-z]/.test(key)){\r\n        patchEvent(el, key, nextValue);\r\n    }\r\n    else{\r\n        patchAttr(el, key, nextValue);\r\n    }\r\n\r\n}"],
  "mappings": "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",
  "names": []
}
