{
  "version": 3,
  "sources": ["../src/index.ts", "../../shared/src/index.ts", "../src/effect.ts", "../src/reactive.ts", "../src/computed.ts"],
  "sourcesContent": ["export {reactive} from './reactive';\r\nexport {effect} from './effect';\r\nexport {computed} from './computed';", "export const isObject = (value:any)=>{\r\n    return value !== null && typeof value === \"object\";\r\n}\r\n\r\nexport const isFunction = (value:any)=>{\r\n    return typeof value === 'function';\r\n}", "// current 'effect'\r\nexport let activeEffect:any = undefined;\r\n\r\nfunction cleanupEffects(effect:any){\r\n    const {deps} = effect;\r\n    for(let i = 0; i < deps.length; i++){\r\n        deps[i].delete(effect);\r\n    }\r\n    effect.deps.length = 0;\r\n}\r\n\r\nexport class ReactiveEffect{\r\n    public active = true;\r\n    public parent = null;\r\n    public deps = [];\r\n\r\n    constructor(public fn:Function, public scheduler:Function) {}\r\n    \r\n    run(){\r\n        if(!this.active){\r\n            return this.fn();\r\n        }\r\n        try{\r\n            // in case be invoked by another 'effect'\r\n            // stack push\r\n            this.parent = activeEffect;\r\n            // set current 'effect'\r\n            activeEffect = this;\r\n            // clean dependencys to collect again\r\n            // in case condition branch\r\n            cleanupEffects(this);\r\n\r\n            return this.fn();\r\n        }\r\n        finally{\r\n            // stack pop\r\n            activeEffect = this.parent;\r\n        }\r\n    }\r\n\r\n    stop(){\r\n        if(this.active){\r\n            this.active = false;\r\n            cleanupEffects(this);\r\n        }\r\n    }\r\n}\r\n\r\nexport function effect(fn:Function, options:any = {}){\r\n    const _effect = new ReactiveEffect(fn, options.scheduler);\r\n    _effect.run();\r\n\r\n    // bind this\r\n    const runner:any = _effect.run.bind(_effect);\r\n    // mount 'effect' on 'runner'\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\n\r\nexport function trackEffects(dep:any){\r\n    if(activeEffect){\r\n        let shouldTrack = !dep.has(activeEffect);\r\n        if(shouldTrack){\r\n            // bidirectional map\r\n            dep.add(activeEffect);\r\n            activeEffect.deps.push(dep);\r\n        }\r\n    }\r\n}\r\n\r\nconst targetMap = new WeakMap();\r\nexport function track(target:any, type:string, key:string|symbol){\r\n    if(!activeEffect) return;\r\n    let depsMap = targetMap.get(target);\r\n    if(!depsMap){\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if(!dep){\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    trackEffects(dep);\r\n}\r\n\r\nexport function triggerEffects(effects:any){\r\n    if(effects){\r\n        // copy to avoid infinite loop\r\n        effects = new Set(effects);\r\n        effects.forEach((effect:any) => {\r\n            // avoid self-recursion\r\n            if(effect !== activeEffect){\r\n                if(effect.scheduler){\r\n                    effect.scheduler();\r\n                }\r\n                else{\r\n                    effect.run();\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nexport function trigger(target:any, type:string, key:string|symbol, value:any, oldValue:any){\r\n    const depsMap = targetMap.get(target);\r\n    if(!depsMap) return;\r\n\r\n    let effects = depsMap.get(key);\r\n\r\n    triggerEffects(effects);\r\n}", "import { isObject } from \"@vue/shared\";\r\nimport { track } from \"./effect\";\r\nimport { trigger } from \"./effect\";\r\n\r\n// record object which has had proxy\r\nconst reactiveMap = new WeakMap();\r\n\r\nconst enum ReactiveFlags {\r\n    IS_REACTIVE = '__v_isReactive'\r\n};\r\n\r\nexport function reactive(target: any){\r\n    // only for Object-type\r\n    if(!isObject(target)){  \r\n        return target;\r\n    }\r\n\r\n    // can have exactly ONE proxy\r\n    const exisitingProxy = reactiveMap.get(target);\r\n    if(exisitingProxy){\r\n        return exisitingProxy;\r\n    }\r\n\r\n    // 'target' has been a proxy\r\n    if(target[ReactiveFlags.IS_REACTIVE]){\r\n        return target;\r\n    }\r\n\r\n    const proxy = new Proxy(target, {\r\n        get(target, key, receiver){\r\n            if(key === ReactiveFlags.IS_REACTIVE){\r\n                return true;\r\n            }\r\n\r\n            track(target, 'get', key);\r\n\r\n            // receiver: proxy\r\n            // change 'this' from 'target' to 'proxy'\r\n            // in case 'get' a attribute which invoke 'get' again\r\n            return Reflect.get(target, key, receiver);\r\n        },\r\n        set(target, key, value, receiver){\r\n            let oldValue = target[key];\r\n            let result = Reflect.set(target, key, value, receiver);\r\n            \r\n            // changed\r\n            if(oldValue !== value){\r\n                trigger(target, 'set', key, value, oldValue);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    })\r\n    // record\r\n    reactiveMap.set(target, proxy);\r\n    return proxy;\r\n}", "import { isFunction } from \"@vue/shared\";\r\nimport { ReactiveEffect, track, trackEffects, triggerEffects } from \"./effect\";\r\n\r\nclass ComputedRefImpl{\r\n    public dep = new Set;\r\n    public effect;\r\n    public _dirty = true;\r\n    public _value:any;\r\n    \r\n    constructor(getter:any, public setter:any){\r\n        this.effect = new ReactiveEffect(getter, () => {\r\n            if(!this._dirty){\r\n                this._dirty = true;\r\n                triggerEffects(this.dep);\r\n            }\r\n        })  \r\n    }\r\n\r\n    get value(){\r\n        // track dependencys\r\n        trackEffects(this.dep);\r\n\r\n        // changed\r\n        if(this._dirty){\r\n            this._value = this.effect.run();   \r\n            this._dirty = false;    \r\n        }\r\n        return this._value;\r\n    }\r\n\r\n    set value(newValue:any){\r\n        this._value = newValue;\r\n        this._dirty = true;\r\n    }\r\n}\r\n\r\nexport function computed(getterOrOptions:any){\r\n    let getter, setter;\r\n    if(isFunction(getterOrOptions)){\r\n        getter = getterOrOptions;\r\n        setter = () => {console.warn('no setter')}\r\n    }\r\n    else{\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter);\r\n}\r\n "],
  "mappings": "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",
  "names": []
}
