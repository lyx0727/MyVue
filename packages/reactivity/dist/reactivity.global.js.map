{
  "version": 3,
  "sources": ["../src/index.ts", "../../shared/src/index.ts", "../src/effect.ts", "../src/reactive.ts", "../src/computed.ts", "../src/watch.ts", "../src/ref.ts"],
  "sourcesContent": ["export {reactive} from './reactive';\r\nexport {effect} from './effect';\r\nexport {computed} from './computed';\r\nexport {watch} from './watch';\r\nexport * from './ref';", "export const isObject = (value:any)=>{\r\n    return value !== null && typeof value === \"object\";\r\n}\r\n\r\nexport const isFunction = (value:any)=>{\r\n    return typeof value === 'function';\r\n}\r\n\r\nexport const isArray = (value:any)=>{\r\n    return Array.isArray(value);\r\n}", "// current 'effect'\r\nexport let activeEffect:any = undefined;\r\n\r\nfunction cleanupEffects(effect:any){\r\n    const {deps} = effect;\r\n    for(let i = 0; i < deps.length; i++){\r\n        deps[i].delete(effect);\r\n    }\r\n    effect.deps.length = 0;\r\n}\r\n\r\nexport class ReactiveEffect{\r\n    public active = true;\r\n    public parent = null;\r\n    public deps = [];\r\n\r\n    constructor(public fn:Function, public scheduler:Function) {}\r\n    \r\n    run(){\r\n        if(!this.active){\r\n            return this.fn();\r\n        }\r\n        try{\r\n            // in case be invoked by another 'effect'\r\n            // stack push\r\n            this.parent = activeEffect;\r\n            // set current 'effect'\r\n            activeEffect = this;\r\n            // clean dependencys to collect again\r\n            // in case condition branch\r\n            cleanupEffects(this);\r\n\r\n            return this.fn();\r\n        }\r\n        finally{\r\n            // stack pop\r\n            activeEffect = this.parent;\r\n        }\r\n    }\r\n\r\n    stop(){\r\n        if(this.active){\r\n            this.active = false;\r\n            cleanupEffects(this);\r\n        }\r\n    }\r\n}\r\n\r\nexport function effect(fn:Function, options:any = {}){\r\n    const _effect = new ReactiveEffect(fn, options.scheduler);\r\n    _effect.run();\r\n\r\n    // bind this\r\n    const runner:any = _effect.run.bind(_effect);\r\n    // mount 'effect' on 'runner'\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\n\r\nexport function trackEffects(dep:any){\r\n    if(activeEffect){\r\n        let shouldTrack = !dep.has(activeEffect);\r\n        if(shouldTrack){\r\n            // bidirectional map\r\n            dep.add(activeEffect);\r\n            activeEffect.deps.push(dep);\r\n        }\r\n    }\r\n}\r\n\r\nconst targetMap = new WeakMap();\r\nexport function track(target:any, type:string, key:string|symbol){\r\n    if(!activeEffect) return;\r\n    let depsMap = targetMap.get(target);\r\n    if(!depsMap){\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if(!dep){\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    trackEffects(dep);\r\n}\r\n\r\nexport function triggerEffects(effects:any){\r\n    if(effects){\r\n        // copy to avoid infinite loop\r\n        effects = new Set(effects);\r\n        effects.forEach((effect:any) => {\r\n            // avoid self-recursion\r\n            if(effect !== activeEffect){\r\n                if(effect.scheduler){\r\n                    effect.scheduler();\r\n                }\r\n                else{\r\n                    effect.run();\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nexport function trigger(target:any, type:string, key:string|symbol, value:any, oldValue:any){\r\n    const depsMap = targetMap.get(target);\r\n    if(!depsMap) return;\r\n\r\n    let effects = depsMap.get(key);\r\n\r\n    triggerEffects(effects);\r\n}", "import { isObject } from \"@vue/shared\";\r\nimport { track } from \"./effect\";\r\nimport { trigger } from \"./effect\";\r\n\r\n// record object which has had proxy\r\nconst reactiveMap = new WeakMap();\r\n\r\nconst enum ReactiveFlags {\r\n    IS_REACTIVE = '__v_isReactive'\r\n};\r\n\r\nexport function isReactive(target:any){\r\n    return target && target[ReactiveFlags.IS_REACTIVE];\r\n}\r\n\r\nexport function reactive(target: any){\r\n    // only for Object-type\r\n    if(!isObject(target)){  \r\n        return target;\r\n    }\r\n\r\n    // can have exactly ONE proxy\r\n    const exisitingProxy = reactiveMap.get(target);\r\n    if(exisitingProxy){\r\n        return exisitingProxy;\r\n    }\r\n\r\n    // 'target' has been a proxy\r\n    if(isReactive(target)){\r\n        return target;\r\n    }\r\n\r\n    const proxy:any = new Proxy(target, {\r\n        get(target, key, receiver){\r\n            if(key === ReactiveFlags.IS_REACTIVE){\r\n                return true;\r\n            }\r\n\r\n            track(target, 'get', key);\r\n\r\n            // receiver: proxy\r\n            // change 'this' from 'target' to 'proxy'\r\n            // in case 'get' a attribute which invoke 'get' again\r\n            const res = Reflect.get(target, key, receiver);\r\n            if(isObject(res)){\r\n                return reactive(res); \r\n            }\r\n            return res;\r\n        },\r\n        set(target, key, value, receiver){\r\n            let oldValue = target[key];\r\n            let result = Reflect.set(target, key, value, receiver);\r\n            \r\n            // changed\r\n            if(oldValue !== value){\r\n                trigger(target, 'set', key, value, oldValue);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    })\r\n    // record\r\n    reactiveMap.set(target, proxy);\r\n    return proxy;\r\n}", "import { isFunction } from \"@vue/shared\";\r\nimport { ReactiveEffect, track, trackEffects, triggerEffects } from \"./effect\";\r\n\r\nclass ComputedRefImpl{\r\n    public dep = new Set;\r\n    public effect;\r\n    public _dirty = true;\r\n    public _value:any;\r\n    \r\n    constructor(getter:any, public setter:any){\r\n        this.effect = new ReactiveEffect(getter, () => {\r\n            if(!this._dirty){\r\n                this._dirty = true;\r\n                triggerEffects(this.dep);\r\n            }\r\n        })  \r\n    }\r\n\r\n    get value(){\r\n        // track dependencys\r\n        trackEffects(this.dep);\r\n\r\n        // changed\r\n        if(this._dirty){\r\n            this._value = this.effect.run();   \r\n            this._dirty = false;    \r\n        }\r\n        return this._value;\r\n    }\r\n\r\n    set value(newValue:any){\r\n        this._value = newValue;\r\n        this._dirty = true;\r\n    }\r\n}\r\n\r\nexport function computed(getterOrOptions:any){\r\n    let getter, setter;\r\n    if(isFunction(getterOrOptions)){\r\n        getter = getterOrOptions;\r\n        setter = () => {console.warn('no setter')}\r\n    }\r\n    else{\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter);\r\n}\r\n ", "import { isFunction, isObject } from \"@vue/shared\";\r\nimport { ReactiveEffect } from \"./effect\";\r\nimport { isReactive } from \"./reactive\";\r\n\r\nfunction traversal(value:any, set:any = new Set){\r\n    if(!isObject(value)){\r\n        return;\r\n    }\r\n    if(set.has(value)){\r\n        return;\r\n    }\r\n    set.add(value);\r\n    for(const key in value){\r\n        traversal(value[key], set);\r\n    }\r\n}\r\n\r\nexport function watch(source:any, cb:Function){\r\n    let getter;\r\n    if(isReactive(source)){\r\n        // make a tranversal to all properties\r\n        getter = () => traversal(source)\r\n    }    \r\n    else if(isFunction(source)){\r\n        getter = source;\r\n    }\r\n    else{\r\n        return;\r\n    }\r\n\r\n    let cleanup:any = undefined;\r\n    const onCleanup = (fn:any)=>{\r\n        cleanup = fn;\r\n    }\r\n\r\n    let oldValue:any = undefined; \r\n    const job = ()=>{\r\n        // invoke 'cleanup' given last time\r\n        if(cleanup){\r\n            cleanup();\r\n        }\r\n        let newValue = effect.run();\r\n        cb(newValue, oldValue, onCleanup);\r\n        oldValue = newValue;\r\n    }\r\n\r\n    const effect = new ReactiveEffect(getter, job);\r\n    oldValue = effect.run();\r\n}", "import { isArray, isObject } from \"@vue/shared\";\r\nimport { trackEffects, triggerEffects } from \"./effect\";\r\nimport { reactive } from \"./reactive\";\r\n\r\nfunction toReactive(value:any){\r\n    return isObject(value) ? reactive(value) : value;\r\n}\r\n\r\nconst enum RefFlags{\r\n    IS_REF = '__v_isRef'\r\n}\r\n\r\nexport function isRef(value:any){\r\n    return value && value[RefFlags.IS_REF];\r\n}\r\n\r\nclass RefImpl{\r\n    public _value:any;\r\n    public __v_isRef = true;\r\n    public dep = new Set;\r\n    constructor(public rawValue:any) {\r\n        this._value = toReactive(rawValue);\r\n    }\r\n\r\n    get value(){\r\n        trackEffects(this.dep);\r\n        return this._value;\r\n    }\r\n\r\n    set value(newValue){\r\n        if(newValue !== this.rawValue){\r\n            this._value = toReactive(newValue);\r\n            this.rawValue = newValue;\r\n            triggerEffects(this.dep);\r\n        }\r\n    }\r\n}\r\n\r\nexport function ref(value:any){\r\n    return new RefImpl(value);\r\n}\r\n\r\nclass ObjectRefImpl{\r\n    constructor(public object:any, public key:string|symbol) {}\r\n\r\n    get value(){\r\n        return this.object[this.key];\r\n    }\r\n\r\n    set value(newValue:any){\r\n        this.object[this.key] = newValue;\r\n    }\r\n}\r\n\r\n// just create a proxy to 'object[key]'\r\n// and you have to use suffix '.value'\r\nexport function toRef(object:any, key:string|symbol){\r\n    return new ObjectRefImpl(object, key);\r\n}\r\n\r\nexport function toRefs(object:any){\r\n    let res:any = isArray(object) ? new Array(object.length) : {};\r\n    for(const key in object){\r\n        res[key] = toRef(object, key);\r\n    }\r\n    return res;\r\n}\r\n\r\n// remove suffix '.value'\r\nexport function proxyRefs(object:any){\r\n    return new Proxy(object, {\r\n        get(target, key, receiver) {\r\n            const r = Reflect.get(target, key, receiver);\r\n            return isRef(r) ? r.value : r;\r\n        },\r\n        set(target, key, value, receiver) {\r\n            const oldValue = target[key];\r\n            if(isRef(oldValue)){\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n            else{\r\n                return Reflect.set(target, key, value, receiver);\r\n            }\r\n        },\r\n    })\r\n}"],
  "mappings": "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",
  "names": []
}
